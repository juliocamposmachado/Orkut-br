import { NextRequest, NextResponse } from 'next/server'

interface MusicInfoRequest {
  artist: string
  title: string
  language?: string
}

// Configura√ß√£o da API do Gemini
const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent"
const API_KEY = process.env.GEMINI_API_KEY

export async function POST(request: NextRequest) {
  try {
    const { artist, title, language = 'pt-BR' }: MusicInfoRequest = await request.json()

    if (!artist || !title) {
      return NextResponse.json(
        { error: 'Artist and title are required' },
        { status: 400 }
      )
    }

    console.log(`üéµ DJ Orky pesquisando informa√ß√µes sobre: ${artist} - ${title}`)

    // Prompt para o Gemini em portugu√™s
    const prompt = `
Voc√™ √© o DJ Orky, um DJ especialista em m√∫sica retr√¥ da R√°dio Tatuap√© FM. 
Preciso que voc√™ analise a m√∫sica "${title}" do(a) artista "${artist}" e forne√ßa informa√ß√µes interessantes e curiosas.

Por favor, responda em formato JSON com as seguintes informa√ß√µes:

1. curiosities: Curiosidades interessantes sobre a m√∫sica (2-3 frases curtas e envolventes)
2. bandInfo: Informa√ß√µes sobre a banda/artista (2-3 frases sobre hist√≥ria, estilo, import√¢ncia)  
3. members: Informa√ß√µes sobre os integrantes principais, vocalistas ou forma√ß√£o (1-2 frases)
4. era: A √©poca/d√©cada da m√∫sica (ex: "Anos 80", "Final dos 90", "In√≠cio dos 2000")
5. genre: G√™nero musical principal (ex: "Pop Rock", "New Wave", "Grunge")
6. funFact: Um fato curioso, interessante ou divertido sobre a m√∫sica ou banda (1 frase impactante)

IMPORTANTE:
- Mantenha as informa√ß√µes precisas e interessantes
- Use linguagem brasileira e descontra√≠da
- Seja espec√≠fico sobre curiosidades reais da m√∫sica/banda
- Se n√£o souber detalhes espec√≠ficos, foque no que √© conhecido sobre o artista
- Responda APENAS o JSON, sem texto adicional

Exemplo:
{
  "curiosities": "Esta m√∫sica foi gravada em apenas uma tomada e se tornou um dos maiores sucessos da d√©cada.",
  "bandInfo": "A banda revolucionou o cen√°rio musical com seu som √∫nico e letras marcantes.",
  "members": "Formada por talentosos m√∫sicos que se conheceram na escola.",
  "era": "Anos 90",
  "genre": "Pop Rock",
  "funFact": "O videoclipe foi gravado com or√ßamento de apenas 50 d√≥lares!"
}
`

    // Chamar a API do Gemini
    const geminiResponse = await fetch(`${API_URL}?key=${API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: prompt
              }
            ]
          }
        ],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 1024,
        },
        safetySettings: [
          {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: "BLOCK_MEDIUM_AND_ABOVE"
          },
          {
            category: "HARM_CATEGORY_HATE_SPEECH",
            threshold: "BLOCK_MEDIUM_AND_ABOVE"
          }
        ]
      })
    })

    if (!geminiResponse.ok) {
      const errorData = await geminiResponse.text()
      console.error('‚ùå Erro na API do Gemini:', geminiResponse.status, errorData)
      throw new Error(`Gemini API error: ${geminiResponse.status}`)
    }

    const geminiData = await geminiResponse.json()
    console.log('üì§ Resposta do Gemini recebida')
    
    // Extrair o texto da resposta do Gemini
    const generatedText = geminiData.candidates?.[0]?.content?.parts?.[0]?.text
    
    if (!generatedText) {
      throw new Error('No content generated by Gemini')
    }

    console.log('üìù Texto gerado pelo Gemini:', generatedText.substring(0, 200) + '...')

    // Tentar fazer parse do JSON gerado
    let musicInfo
    try {
      // Limpar o texto e tentar extrair o JSON
      let jsonText = generatedText.trim()
      
      // Remover poss√≠veis marcadores de c√≥digo se existirem
      jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '')
      
      // Tentar encontrar o JSON na resposta
      const jsonMatch = jsonText.match(/\{[\s\S]*\}/)
      if (jsonMatch) {
        jsonText = jsonMatch[0]
      }
      
      musicInfo = JSON.parse(jsonText)
      console.log('‚úÖ JSON parsed com sucesso')
    } catch (parseError) {
      console.error('‚ùå Erro ao fazer parse do JSON do Gemini:', parseError)
      console.log('üîç Texto completo gerado:', generatedText)
      
      // Fallback se o JSON estiver malformado
      musicInfo = {
        curiosities: `"${title}" √© uma m√∫sica ic√¥nica de ${artist} que marcou uma gera√ß√£o com sua sonoridade √∫nica.`,
        bandInfo: `${artist} √© reconhecido(a) mundialmente por sua contribui√ß√£o √∫nica para a m√∫sica e por sucessos atemporais.`,
        members: `A forma√ß√£o de ${artist} conta com talentosos m√∫sicos que criaram um som inconfund√≠vel.`,
        era: 'Cl√°ssico Atemporal',
        genre: 'Pop/Rock',
        funFact: `"${title}" continua sendo uma das m√∫sicas mais pedidas pelos ouvintes das r√°dios!`
      }
    }

    // Garantir que temos todos os campos necess√°rios
    musicInfo.artist = artist
    musicInfo.title = title
    musicInfo.recommendation = `Continue ouvindo a R√°dio Tatuap√© FM para descobrir mais sucessos como "${title}"!`

    console.log('‚úÖ Informa√ß√µes processadas para:', `${artist} - ${title}`)

    return NextResponse.json({
      success: true,
      musicInfo,
      source: 'gemini',
      timestamp: new Date().toISOString()
    })

  } catch (error: any) {
    console.error('‚ùå Erro na API do DJ Orky Music Info:', error)
    
    // Em caso de erro, retornar informa√ß√µes b√°sicas mas interessantes
    let fallbackData
    try {
      fallbackData = await request.json()
    } catch {
      fallbackData = { artist: 'Artista Desconhecido', title: 'M√∫sica' }
    }
    
    const { artist = 'Artista', title = 'M√∫sica' } = fallbackData

    return NextResponse.json({
      success: true, // Ainda retornamos sucesso para n√£o quebrar a interface
      musicInfo: {
        artist,
        title,
        curiosities: `"${title}" √© uma m√∫sica especial que faz parte da trilha sonora de muitas mem√≥rias. ${artist} conquistou f√£s com essa obra marcante!`,
        bandInfo: `${artist} √© um(a) artista que deixou sua marca na hist√≥ria da m√∫sica, criando sucessos que atravessam gera√ß√µes.`,
        members: `A forma√ß√£o musical por tr√°s de "${title}" demonstra o talento e a paix√£o pela m√∫sica que define ${artist}.`,
        era: 'Era Dourada',
        genre: 'Cl√°ssico',
        funFact: `Toda vez que "${title}" toca na r√°dio, √© imposs√≠vel n√£o cantar junto!`,
        recommendation: `Continue ligado na R√°dio Tatuap√© FM para mais sucessos atemporais como este!`
      },
      source: 'error_fallback',
      error: error.message,
      timestamp: new Date().toISOString()
    })
  }
}

// Endpoint GET para testar a API
export async function GET(request: NextRequest) {
  return NextResponse.json({
    message: 'DJ Orky Music Info API',
    status: 'online',
    usage: 'POST com { artist: "Nome do Artista", title: "Nome da M√∫sica" }',
    timestamp: new Date().toISOString()
  })
}
